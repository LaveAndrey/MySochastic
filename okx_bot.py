import sqlite3
import time
from datetime import datetime
from decimal import ROUND_DOWN
from decimal import Decimal
from typing import Tuple, Optional
import os

import logging
logger = logging.getLogger(__name__)

DB_NAME = os.path.abspath("data/positions.db")  # –ü—É—Ç—å –±—É–¥–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –≤–µ–∑–¥–µ

def init_db():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏ –¥–ª—è SPOT –∏ SHORT –ø–æ–∑–∏—Ü–∏–π"""
    try:
        logger.info(f"[INFO] üîß –ù–∞—á–∏–Ω–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ë–î: {DB_NAME}")
        with sqlite3.connect(DB_NAME) as conn:
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è SPOT-–ø–æ–∑–∏—Ü–∏–π
            logger.info("[INFO] –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–±–ª–∏—Ü—É long_positions...")
            conn.execute("""
            CREATE TABLE IF NOT EXISTS long_positions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT ,
                entry_price REAL,
                entry_time TEXT,
                exit_price REAL,
                exit_time TEXT,
                pnl_percent REAL,
                pnl_usdt REAL,
                order_id TEXT,
                closed INTEGER DEFAULT 0,
                leverage INTEGER DEFAULT 1,
                amount REAL,
                side TEXT,
                fee REAL DEFAULT 0,
                reason TEXT DEFAULT NULL
            )
            """)
            logger.info("[INFO] ‚úÖ –¢–∞–±–ª–∏—Ü–∞ long_positions –≥–æ—Ç–æ–≤–∞")

            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è SHORT (–º–∞—Ä–∂–∏–Ω–∞–ª—å–Ω—ã—Ö) –ø–æ–∑–∏—Ü–∏–π
            logger.info("[INFO] –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–±–ª–∏—Ü—É short_positions...")
            conn.execute("""
            CREATE TABLE IF NOT EXISTS short_positions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT ,
                entry_price REAL,
                entry_time TEXT,
                exit_price REAL,
                exit_time TEXT,
                pnl_percent REAL,
                pnl_usdt REAL,
                order_id TEXT,
                closed INTEGER DEFAULT 0,
                leverage INTEGER DEFAULT 1,
                amount REAL,
                side TEXT,
                fee REAL DEFAULT 0,
                reason TEXT DEFAULT NULL,
                pos_id TEXT
            )
            """)
            logger.info("[INFO] ‚úÖ –¢–∞–±–ª–∏—Ü–∞ short_positions –≥–æ—Ç–æ–≤–∞")


        logger.info(f"[INFO] –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö {DB_NAME} –ø–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ")

    except Exception as e:
        logger.error(f"[ERROR] üî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")


def has_open_position(symbol):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏ –≤ –æ–±–µ–∏—Ö —Ç–∞–±–ª–∏—Ü–∞—Ö: spot –∏ short"""
    logger.debug(f"[DEBUG] üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {symbol}")
    try:
        with sqlite3.connect(DB_NAME) as conn:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ SPOT
            long_result = conn.execute("""
                SELECT COUNT(*) FROM long_positions 
                WHERE symbol=? AND closed=0
            """, (symbol,)).fetchone()[0]

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ SHORT
            short_result = conn.execute("""
                SELECT COUNT(*) FROM short_positions 
                WHERE symbol=? AND closed=0
            """, (symbol,)).fetchone()[0]

            if long_result > 0:
                details = conn.execute("""
                    SELECT entry_price, entry_time FROM long_positions 
                    WHERE symbol=? AND closed=0 LIMIT 1
                """, (symbol,)).fetchone()
                logger.info(f"[INFO] ‚õî –û—Ç–∫—Ä—ã—Ç–∞ LONG-–ø–æ–∑–∏—Ü–∏—è –ø–æ {symbol}")
                logger.debug(f"[DEBUG] LONG: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞={details[0]}, –í—Ä–µ–º—è={details[1]}")

            if short_result > 0:
                details = conn.execute("""
                    SELECT entry_price, entry_time FROM short_positions 
                    WHERE symbol=? AND closed=0 LIMIT 1
                """, (symbol,)).fetchone()
                logger.info(f"[INFO] ‚õî –û—Ç–∫—Ä—ã—Ç–∞ SHORT-–ø–æ–∑–∏—Ü–∏—è –ø–æ {symbol}")
                logger.debug(f"[DEBUG] SHORT: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞={details[0]}, –í—Ä–µ–º—è={details[1]}")

            if long_result == 0 and short_result == 0:
                logger.debug(f"[DEBUG] ‚úÖ –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π –ø–æ {symbol}")

            return (long_result + short_result) > 0

    except Exception as e:
        logger.error(f"[ERROR] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–∑–∏—Ü–∏–∏ {symbol}: {str(e)}")
        return False


def log_position(symbol, position_type, price, timestamp, order_id,
                 leverage=None, amount=None, side=None, pos_id=None):
    """
    –õ–æ–≥–∏—Ä—É–µ—Ç –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –≤ —Ç–∞–±–ª–∏—Ü—É long_positions –∏–ª–∏ short_positions

    Args:
        symbol: –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "BTC-USDT-SWAP")
        position_type: –¢–∏–ø –ø–æ–∑–∏—Ü–∏–∏ ("LONG" –∏–ª–∏ "SHORT")
        price: –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞
        timestamp: –í—Ä–µ–º—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
        order_id: ID –æ—Ä–¥–µ—Ä–∞
        leverage: –ü–ª–µ—á–æ (–¥–ª—è –º–∞—Ä–∂–∏–Ω–∞–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π)
        amount: –û–±—ä—ë–º –ø–æ–∑–∏—Ü–∏–∏
        side: –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏ ("buy" –∏–ª–∏ "sell")
    """
    logger.info(f"[INFO] üìù –õ–æ–≥–∏—Ä—É–µ–º –Ω–æ–≤—É—é {position_type.upper()} –ø–æ–∑–∏—Ü–∏—é: {symbol} –ø–æ —Ü–µ–Ω–µ {price}")
    logger.debug(f"[DEBUG] –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:\n"
                 f"Symbol: {symbol}\n"
                 f"Type: {position_type}\n"
                 f"Price: {price}\n"
                 f"Time: {timestamp}\n"
                 f"Order ID: {order_id}\n"
                 f"Leverage: {leverage}\n"
                 f"Amount: {amount}\n"
                 f"Side: {side}\n"
                 f"Pos ID: {pos_id}")

    safe_amount = amount if amount is not None else 0.0

    try:
        with sqlite3.connect(DB_NAME) as conn:
            if position_type.upper() == "LONG":
                table = "long_positions"
            elif position_type.upper() == "SHORT":
                table = "short_positions"
            else:
                logger.warning(f"[WARNING] ‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–æ–∑–∏—Ü–∏–∏: {position_type}. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø–∏—Å—å.")
                return

            existing = conn.execute(
                f"SELECT id FROM {table} WHERE symbol=? AND closed=0",
                (symbol,)
            ).fetchone()

            if existing:
                logger.info(f"[INFO] üö´ –ü–æ–∑–∏—Ü–∏—è {symbol} ({position_type}) —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –∞–∫—Ç–∏–≤–Ω–∞. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ.")
                return

            if position_type.upper() == "LONG":
                conn.execute(f"""
                    INSERT INTO {table} 
                    (symbol, entry_price, entry_time, order_id, leverage, amount, side)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    symbol, price, timestamp, order_id, leverage,
                    safe_amount, side
                ))
                logger.info(f"[INFO] ‚úÖ LONG –ø–æ–∑–∏—Ü–∏—è {symbol} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–∞")

            elif position_type.upper() == "SHORT":
                conn.execute(f"""
                    INSERT INTO {table} 
                    (symbol, entry_price, entry_time, order_id, leverage, amount, side, pos_id)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    symbol, price, timestamp, order_id, leverage,
                    safe_amount, side, pos_id
                ))
                logger.info(f"[INFO] ‚úÖ SHORT –ø–æ–∑–∏—Ü–∏—è {symbol} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–∞")

    except sqlite3.Error as e:
        logger.error(f"[ERROR] üî• –û—à–∏–±–∫–∞ SQL –ø—Ä–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏ {symbol}: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"[ERROR] üî• –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–æ–∑–∏—Ü–∏–∏ {symbol}: {str(e)}")
        raise






def place_long_order(
        trade_api,
        account_api,
        market_api,
        symbol: str,
        amount_usdt: float,
        position_monitor,
        timestamp: str,
        leverage: int
) -> bool:
    """
    –†–∞–∑–º–µ—â–∞–µ—Ç BUY –æ—Ä–¥–µ—Ä —Å —Ä–∞—Å—á—ë—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (LONG –ø–æ–∑–∏—Ü–∏—è)

    Args:
        trade_api: API –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏
        account_api: API –∞–∫–∫–∞—É–Ω—Ç–∞
        market_api: API —Ä—ã–Ω–∫–∞
        symbol: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä "BTC")
        amount_usdt: –°—É–º–º–∞ –≤ USDT –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
        position_monitor: –û–±—ä–µ–∫—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–æ–∑–∏—Ü–∏–π
        timestamp: –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
        leverage: –ü–ª–µ—á–æ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1)

    Returns:
        bool: True –µ—Å–ª–∏ –æ—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω, False –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    """
    try:
        formatted_symbol = f"{symbol}-USDT-SWAP"
        logger.info(f"[INFO] –ù–∞—á–∞–ª–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è LONG –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {formatted_symbol}")

        if has_open_position(formatted_symbol):
            logger.warning(f"[WARNING] ‚è∏Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ–∫—É–ø–∫—É {symbol} - –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞")
            return False

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        logger.info(f"[INFO] üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–ª—è {formatted_symbol}...")
        contract = get_swap_contract(symbol, market_api, account_api)
        if not contract:
            logger.error(f"[ERROR] ‚ùå –ö–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è {formatted_symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ
        leverage_res = account_api.set_leverage(
            instId=formatted_symbol,
            lever=str(leverage),
            mgnMode="isolated",
            posSide="long",
        )
        if leverage_res.get('code') != '0':
            raise ValueError(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞: {leverage_res.get('msg')}")
        logger.info(f"[INFO] ‚úÖ –ü–ª–µ—á–æ {leverage}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")

        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
        ticker = market_api.get_ticker(formatted_symbol)
        if ticker.get('code') != '0':
            raise ValueError(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã: {ticker.get('msg')}")
        current_price = Decimal(ticker['data'][0]['last'])
        logger.info(f"[INFO] üíµ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {current_price}")

        # –†–∞—Å—á—ë—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
        def calculate_size():
            ct_val = Decimal(contract['ctVal'])
            lot_sz = Decimal(contract['lotSz'])
            min_sz = Decimal(contract['minSz'])

            raw_size = Decimal(amount_usdt) / (current_price * ct_val)
            rounded_size = (raw_size // lot_sz) * lot_sz
            return max(min_sz, rounded_size)

        size = calculate_size()

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
        balance_data = account_api.get_account_balance(ccy="USDT")
        if balance_data.get("code") != "0":
            return False

        available_balance = Decimal(balance_data['data'][0]['details'][0]['availBal'])
        required_margin = (size * current_price) / Decimal(leverage)

        if available_balance < required_margin:
            logger.error(f"[ERROR] üí∏ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤: –Ω—É–∂–Ω–æ {required_margin}, –¥–æ—Å—Ç—É–ø–Ω–æ {available_balance}")
            return False

        logger.info(f"[INFO] üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É...")
        order = trade_api.place_order(
            instId=formatted_symbol,
            tdMode="isolated",
            side="buy",
            posSide="long",
            ordType="market",
            sz=str(size.quantize(Decimal('0.00000001')))
        )

        if order.get('code') != '0':
            error_data = order.get('data', [{}])[0]
            logger.error(f"""
            [ERROR] –û—à–∏–±–∫–∞ –æ—Ä–¥–µ—Ä–∞:
            –ö–æ–¥: {order.get('code')}
            –°–æ–æ–±—â–µ–Ω–∏–µ: {order.get('msg')}
            –î–µ—Ç–∞–ª–∏: {error_data.get('sMsg', '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}
            """)
            return False

        order_id = order['data'][0].get('ordId')
        logger.info(f"[INFO] üéâ –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω. ID: {order_id}")

        log_position(
            symbol=formatted_symbol,
            position_type="LONG",
            price=float(current_price),
            timestamp=timestamp,
            order_id=order_id,
            leverage=leverage,
            amount=float(size),
            side="buy",
        )

        position_monitor._start_timer(formatted_symbol, position_monitor.close_after_seconds)
        logger.info(f"[SUCCESS] ‚úÖ LONG –ø–æ–∑–∏—Ü–∏—è –ø–æ {formatted_symbol} —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞ —Å–æ —Å—Ç–æ–ø-–ª–æ—Å—Å–æ–º")

        return True

    except ValueError as ve:
        logger.error(f"[ERROR] ‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(ve)}")
        return False
    except Exception as e:
        logger.error(f"[ERROR] üî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
        return False



def get_swap_contract(symbol: str, market_api, account_api) -> dict:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ (–≤–∫–ª—é—á–∞—è ctVal) –¥–ª—è symbol, –Ω–∞–ø—Ä–∏–º–µ—Ä 'BTC'
    """
    try:
        contracts = account_api.get_instruments(instType="SWAP")
        for contract in contracts.get("data", []):
            if contract["instId"].startswith(f"{symbol.upper()}-USDT"):
                logger.info(contract)
                return contract
        raise ValueError(f"–ö–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è {symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
        raise RuntimeError(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞: {e}")

def fetch_pos_id(account_api, inst_id: str, pos_side: str = "short") -> Optional[str]:
    """
    –ü–æ–ª—É—á–∏—Ç—å posId –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏ –ø–æ instId –∏ posSide
    :param account_api: API –∞–∫–∫–∞—É–Ω—Ç–∞
    :param inst_id: —Å–∏–º–≤–æ–ª –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "BTC-USDT-SWAP"
    :param pos_side: "short" –∏–ª–∏ "long"
    :return: posId –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    """
    res = account_api.get_positions(instType="SWAP", instId=inst_id)
    if res.get("code") != "0":
        logger.error(f"[ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π: {res.get('msg')}")
        return None
    positions = res.get("data", [])
    for pos in positions:
        if pos.get("instId") == inst_id and pos.get("posSide") == pos_side and float(pos.get("pos", "0")) > 0:
            return pos.get("posId")
    return None

def place_sell_order(
        trade_api,
        account_api,
        market_api,
        symbol: str,
        amount_usdt: float,
        position_monitor,
        timestamp: str,
        leverage: int
) -> bool:
    """
    –†–∞–∑–º–µ—â–∞–µ—Ç SELL –æ—Ä–¥–µ—Ä —Å —Ä–∞—Å—á—ë—Ç–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (SHORT –ø–æ–∑–∏—Ü–∏—è)

    Args:
        trade_api: API –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏
        account_api: API –∞–∫–∫–∞—É–Ω—Ç–∞
        market_api: API —Ä—ã–Ω–∫–∞
        symbol: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä "BTC")
        amount_usdt: –°—É–º–º–∞ –≤ USDT –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
        position_monitor: –û–±—ä–µ–∫—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–æ–∑–∏—Ü–∏–π
        timestamp: –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏
        leverage: –ü–ª–µ—á–æ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 4)

    Returns:
        bool: True –µ—Å–ª–∏ –æ—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω, False –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    """
    try:
        # 0. –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∏–º–≤–æ–ª –¥–ª—è OKX
        formatted_symbol = f"{symbol}-USDT-SWAP"
        logger.info(f"[INFO] –ù–∞—á–∞–ª–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è SHORT –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {formatted_symbol}")

        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Ç –ª–∏ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏
        if has_open_position(formatted_symbol):
            logger.warning(f"[WARNING] ‚è∏Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–¥–∞–∂—É {symbol} - –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞")
            return False

        # 2. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        logger.info(f"[INFO] üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ –¥–ª—è {formatted_symbol}...")
        contract = get_swap_contract(symbol, market_api, account_api)
        if not contract:
            logger.error(f"[ERROR] ‚ùå –ö–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è {formatted_symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False

        # 3. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ
        leverage_res = account_api.set_leverage(
            instId=formatted_symbol,
            lever=str(leverage),
            mgnMode="isolated",
            posSide="short",
        )
        if leverage_res.get('code') != '0':
            raise ValueError(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞: {leverage_res.get('msg')}")
        logger.info(f"[INFO] ‚úÖ –ü–ª–µ—á–æ {leverage}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")

        # 4. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
        ticker = market_api.get_ticker(formatted_symbol)
        if ticker.get('code') != '0':
            raise ValueError(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã: {ticker.get('msg')}")
        current_price = Decimal(ticker['data'][0]['last'])
        logger.info(f"[INFO] üíµ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {current_price}")

        # 5. –†–∞—Å—á—ë—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤: USDT / (—Ü–µ–Ω–∞ * —Ä–∞–∑–º–µ—Ä_–∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞)
        def calculate_size():
            ct_val = Decimal(contract['ctVal'])
            lot_sz = Decimal(contract['lotSz'])
            min_sz = Decimal(contract['minSz'])

            raw_size = Decimal(amount_usdt) / (current_price * ct_val)
            # –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –±–ª–∏–∂–∞–π—à–µ–≥–æ –∫—Ä–∞—Ç–Ω–æ–≥–æ lot_sz –≤–Ω–∏–∑
            rounded_size = (raw_size // lot_sz) * lot_sz
            return max(min_sz, rounded_size)

        size = calculate_size()

        # 6. –†–∞–∑–º–µ—â–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞
        balance_data = account_api.get_account_balance(ccy="USDT")
        if balance_data.get("code") != "0":
            return False

        available_balance = Decimal(balance_data['data'][0]['details'][0]['availBal'])
        required_margin = (size * current_price) / Decimal(leverage)

        if available_balance < required_margin:
            return False

        logger.info(f"[INFO] üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É...")
        order = trade_api.place_order(
            instId=formatted_symbol,
            tdMode="isolated",
            side="sell",
            posSide="short",
            ordType="market",
            sz=str(size.quantize(Decimal('0.00000001')))
        )

        if order.get('code') != '0':
            error_data = order.get('data', [{}])[0]
            logger.error(f"""
            [ERROR] –û—à–∏–±–∫–∞ –æ—Ä–¥–µ—Ä–∞:
            –ö–æ–¥: {order.get('code')}
            –°–æ–æ–±—â–µ–Ω–∏–µ: {order.get('msg')}
            –î–µ—Ç–∞–ª–∏: {error_data.get('sMsg', '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö')}
            """)
            return False

        order_id = order['data'][0].get('ordId')
        logger.info(f"[INFO] üéâ –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω. ID: {order_id}")

        time.sleep(2)

        pos_id = fetch_pos_id(account_api, formatted_symbol, pos_side="short")
        if not pos_id:
            logger.warning(f"[WARN] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å posId –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ {formatted_symbol}")


        log_position(
            symbol=formatted_symbol,
            position_type="SHORT",
            price=float(current_price),
            timestamp=timestamp,
            order_id=order_id,
            leverage=leverage,
            amount=float(size),
            side="sell",
            pos_id=pos_id
        )

        position_monitor._start_timer(formatted_symbol, position_monitor.close_after_seconds)
        logger.info(f"[SUCCESS] ‚úÖ SHORT –ø–æ–∑–∏—Ü–∏—è –ø–æ {formatted_symbol} —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞ —Å–æ —Å—Ç–æ–ø-–ª–æ—Å—Å–æ–º")

        return True

    except ValueError as ve:
        logger.error(f"[ERROR] ‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(ve)}")
        return False
    except Exception as e:
        logger.error(f"[ERROR] üî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
        return False

